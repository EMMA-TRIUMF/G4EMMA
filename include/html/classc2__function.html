<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>G4EMMA Header Files: c2_function&lt; float_type &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">G4EMMA Header Files
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Groups</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classc2__function-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">c2_function&lt; float_type &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__abstract__classes.html">Abstract Classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>the parent class for all c2_functions.c2_functions know their value, first, and second derivative at almost every point. They can be efficiently combined with binary operators, via <a class="el" href="classc2__binary__function.html" title="Provides support for c2_function objects which are constructed from two other c2_function objects...">c2_binary_function</a>, composed via c2_composed_function_, have their roots found via <a class="el" href="classc2__function.html#acd17a7191226578c866d82cb2e9ff89f" title="solve f(x)==value very efficiently, with explicit knowledge of derivatives of the function ...">find_root()</a>, and be adaptively integrated via <a class="el" href="classc2__function.html#a89ce5e2f44ebfaf9eb4d66605cde4fde" title="for points in xgrid, adaptively return Integral[f(x),{x,xgrid[i],xgrid[i+1]}] and return in vector...">partial_integrals()</a> or <a class="el" href="classc2__function.html#a675c5056562332be2e49b38485d322b7" title="a fully-automated integrator which uses the information provided by the get_sampling_grid() function ...">integral()</a>. They also can carry information with them about how to find 'interesting' points on the function. This information is set with <a class="el" href="classc2__function.html#a23828c75121b442899ab7a80cf5abbb0" title="establish a grid of &#39;interesting&#39; points on the function. ">set_sampling_grid()</a> and extracted with <a class="el" href="classc2__function.html#ad03264dcc015e5d0b1b6eb30df3f32be" title="return the grid of &#39;interesting&#39; points along this function which lie in the region requested ...">get_sampling_grid()</a>.  
 <a href="classc2__function.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="c2__function_8hh_source.html">c2_function.hh</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for c2_function&lt; float_type &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classc2__function.png" usemap="#c2_function&lt; float_type &gt;_map" alt=""/>
  <map id="c2_function&lt; float_type &gt;_map" name="c2_function&lt; float_type &gt;_map">
<area href="classc2__binary__function.html" title="Provides support for c2_function objects which are constructed from two other c2_function objects..." alt="c2_binary_function&lt; float_type &gt;" shape="rect" coords="245,56,480,80"/>
<area href="classc2__cached__function__p.html" title="A container into which any other c2_function can be dropped.It allows a function to be pre-evaluated ..." alt="c2_cached_function_p&lt; float_type &gt;" shape="rect" coords="245,112,480,136"/>
<area href="classc2__classic__function__p.html" title="a container into which any conventional c-style function can be dropped, to create a degenerate c2_fu..." alt="c2_classic_function_p&lt; float_type &gt;" shape="rect" coords="245,168,480,192"/>
<area href="classc2__connector__function__p.html" title="create a c2_function which smoothly connects two other c2_functions.This takes two points and generat..." alt="c2_connector_function_p&lt; float_type &gt;" shape="rect" coords="245,224,480,248"/>
<area href="classc2__constant__p.html" title="a c2_function which is constantThe factory function c2_factory::constant() creates *new c2_constant_p..." alt="c2_constant_p&lt; float_type &gt;" shape="rect" coords="245,280,480,304"/>
<area href="classc2__exp__p.html" title="compute exp(x) with its derivatives.The factory function c2_factory::exp() creates *new c2_exp_p ..." alt="c2_exp_p&lt; float_type &gt;" shape="rect" coords="245,336,480,360"/>
<area href="classc2__identity__p.html" title="compute x with its derivatives.The factory function c2_factory::identity() creates *new c2_identity_p..." alt="c2_identity_p&lt; float_type &gt;" shape="rect" coords="245,392,480,416"/>
<area href="classc2__inverse__function__p.html" title="create the formal inverse function of another functionfor example, given a c2_function f ..." alt="c2_inverse_function_p&lt; float_type &gt;" shape="rect" coords="245,448,480,472"/>
<area href="classc2__linear__p.html" title="create a linear mapping of another functionfor example, given a c2_function f " alt="c2_linear_p&lt; float_type &gt;" shape="rect" coords="245,504,480,528"/>
<area href="classc2__log__p.html" title="compute log(x) with its derivatives.The factory function c2_factory::log() creates *new c2_log_p ..." alt="c2_log_p&lt; float_type &gt;" shape="rect" coords="245,560,480,584"/>
<area href="classc2__piecewise__function__p.html" title="create a c2_function which is a piecewise assembly of other c2_functions.The functions must have incr..." alt="c2_piecewise_function_p&lt; float_type &gt;" shape="rect" coords="245,616,480,640"/>
<area href="classc2__plugin__function__p.html" title="a container into which any other c2_function can be dropped, to allow expressions with replacable com..." alt="c2_plugin_function_p&lt; float_type &gt;" shape="rect" coords="245,672,480,696"/>
<area href="classc2__power__law__p.html" title="create a power law mapping of another functionfor example, given a c2_function f " alt="c2_power_law_p&lt; float_type &gt;" shape="rect" coords="245,728,480,752"/>
<area href="classc2__quadratic__p.html" title="create a quadratic mapping of another functionfor example, given a c2_function f " alt="c2_quadratic_p&lt; float_type &gt;" shape="rect" coords="245,784,480,808"/>
<area href="classc2__recip__p.html" title="compute scale/x with its derivatives.The factory function c2_factory::recip() creates *new c2_recip_p..." alt="c2_recip_p&lt; float_type &gt;" shape="rect" coords="245,840,480,864"/>
<area href="classc2__scaled__function__p.html" title="Create a very lightweight method to return a scalar multiple of another function. \ \The factory func..." alt="c2_scaled_function_p&lt; float_type &gt;" shape="rect" coords="245,896,480,920"/>
<area href="classc2__sin__p.html" title="compute sin(x) with its derivatives.The factory function c2_factory::sin() creates *new c2_sin_p ..." alt="c2_sin_p&lt; float_type &gt;" shape="rect" coords="245,952,480,976"/>
<area href="classc2__sqrt__p.html" title="compute sqrt(x) with its derivatives.The factory function c2_factory::sqrt() creates *new c2_sqrt_p()..." alt="c2_sqrt_p&lt; float_type &gt;" shape="rect" coords="245,1008,480,1032"/>
<area href="classc2__tan__p.html" title="compute tan(x) with its derivatives.The factory function c2_factory::tan() creates *new c2_tan_p ..." alt="c2_tan_p&lt; float_type &gt;" shape="rect" coords="245,1064,480,1088"/>
<area href="classinterpolating__function__p.html" title="create a cubic spline interpolation of a set of (x,y) pairsThis is one of the main reasons for c2_fun..." alt="interpolating_function_p&lt; float_type &gt;" shape="rect" coords="245,1120,480,1144"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a851a9e8dca6e8fa9c2da12c8705566b2"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc2__function.html#a851a9e8dca6e8fa9c2da12c8705566b2">cvs_header_vers</a> () const </td></tr>
<tr class="memdesc:a851a9e8dca6e8fa9c2da12c8705566b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">get versioning information for the header file  <a href="#a851a9e8dca6e8fa9c2da12c8705566b2">More...</a><br/></td></tr>
<tr class="separator:a851a9e8dca6e8fa9c2da12c8705566b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2304b7543724be829571336da02b0f91"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc2__function.html#a2304b7543724be829571336da02b0f91">cvs_file_vers</a> () const </td></tr>
<tr class="memdesc:a2304b7543724be829571336da02b0f91"><td class="mdescLeft">&#160;</td><td class="mdescRight">get versioning information for the source file  <a href="#a2304b7543724be829571336da02b0f91">More...</a><br/></td></tr>
<tr class="separator:a2304b7543724be829571336da02b0f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab17870e5af508c66ec154195b837466e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab17870e5af508c66ec154195b837466e"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc2__function.html#ab17870e5af508c66ec154195b837466e">~c2_function</a> ()</td></tr>
<tr class="memdesc:ab17870e5af508c66ec154195b837466e"><td class="mdescLeft">&#160;</td><td class="mdescRight">destructor <br/></td></tr>
<tr class="separator:ab17870e5af508c66ec154195b837466e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44e0201159111350be7f746fc9026f67"><td class="memItemLeft" align="right" valign="top">virtual float_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc2__function.html#a44e0201159111350be7f746fc9026f67">value_with_derivatives</a> (float_type x, float_type *yprime, float_type *yprime2) const =0  throw (c2_exception)</td></tr>
<tr class="memdesc:a44e0201159111350be7f746fc9026f67"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the value and derivatives.  <a href="#a44e0201159111350be7f746fc9026f67">More...</a><br/></td></tr>
<tr class="separator:a44e0201159111350be7f746fc9026f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0658cb22966f0ff9072d4d0e04b54c61"><td class="memItemLeft" align="right" valign="top">float_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc2__function.html#a0658cb22966f0ff9072d4d0e04b54c61">operator()</a> (float_type x) const   throw (c2_exception)</td></tr>
<tr class="memdesc:a0658cb22966f0ff9072d4d0e04b54c61"><td class="mdescLeft">&#160;</td><td class="mdescRight">evaluate the function in the classic way, ignoring derivatives.  <a href="#a0658cb22966f0ff9072d4d0e04b54c61">More...</a><br/></td></tr>
<tr class="separator:a0658cb22966f0ff9072d4d0e04b54c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25c89b64e6cbd749314d0a61063240cc"><td class="memItemLeft" align="right" valign="top">float_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc2__function.html#a25c89b64e6cbd749314d0a61063240cc">operator()</a> (float_type x, float_type *yprime, float_type *yprime2) const   throw (c2_exception)</td></tr>
<tr class="memdesc:a25c89b64e6cbd749314d0a61063240cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the value and derivatives.  <a href="#a25c89b64e6cbd749314d0a61063240cc">More...</a><br/></td></tr>
<tr class="separator:a25c89b64e6cbd749314d0a61063240cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd17a7191226578c866d82cb2e9ff89f"><td class="memItemLeft" align="right" valign="top">float_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc2__function.html#acd17a7191226578c866d82cb2e9ff89f">find_root</a> (float_type lower_bracket, float_type upper_bracket, float_type start, float_type value, int *error=0, float_type *final_yprime=0, float_type *final_yprime2=0) const   throw (c2_exception)</td></tr>
<tr class="memdesc:acd17a7191226578c866d82cb2e9ff89f"><td class="mdescLeft">&#160;</td><td class="mdescRight">solve f(x)==value very efficiently, with explicit knowledge of derivatives of the function  <a href="#acd17a7191226578c866d82cb2e9ff89f">More...</a><br/></td></tr>
<tr class="separator:acd17a7191226578c866d82cb2e9ff89f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89ce5e2f44ebfaf9eb4d66605cde4fde"><td class="memItemLeft" align="right" valign="top">float_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc2__function.html#a89ce5e2f44ebfaf9eb4d66605cde4fde">partial_integrals</a> (std::vector&lt; float_type &gt; xgrid, std::vector&lt; float_type &gt; *partials=0, float_type abs_tol=1e-12, float_type rel_tol=1e-12, int derivs=2, bool adapt=true, bool extrapolate=true) const   throw (c2_exception)</td></tr>
<tr class="memdesc:a89ce5e2f44ebfaf9eb4d66605cde4fde"><td class="mdescLeft">&#160;</td><td class="mdescRight">for points in xgrid, adaptively return Integral[f(x),{x,xgrid[i],xgrid[i+1]}] and return in vector, along with sum  <a href="#a89ce5e2f44ebfaf9eb4d66605cde4fde">More...</a><br/></td></tr>
<tr class="separator:a89ce5e2f44ebfaf9eb4d66605cde4fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a675c5056562332be2e49b38485d322b7"><td class="memItemLeft" align="right" valign="top">float_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc2__function.html#a675c5056562332be2e49b38485d322b7">integral</a> (float_type amin, float_type amax, std::vector&lt; float_type &gt; *partials=0, float_type abs_tol=1e-12, float_type rel_tol=1e-12, int derivs=2, bool adapt=true, bool extrapolate=true) const   throw (c2_exception)</td></tr>
<tr class="memdesc:a675c5056562332be2e49b38485d322b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">a fully-automated integrator which uses the information provided by the <a class="el" href="classc2__function.html#ad03264dcc015e5d0b1b6eb30df3f32be" title="return the grid of &#39;interesting&#39; points along this function which lie in the region requested ...">get_sampling_grid()</a> function to figure out what to do.  <a href="#a675c5056562332be2e49b38485d322b7">More...</a><br/></td></tr>
<tr class="separator:a675c5056562332be2e49b38485d322b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea75f73d6a97087571c163ae4e514652"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classc2__piecewise__function__p.html">c2_piecewise_function_p</a><br class="typebreak"/>
&lt; float_type &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc2__function.html#aea75f73d6a97087571c163ae4e514652">adaptively_sample</a> (float_type amin, float_type amax, float_type abs_tol=1e-12, float_type rel_tol=1e-12, int derivs=2, std::vector&lt; float_type &gt; *xvals=0, std::vector&lt; float_type &gt; *yvals=0) const   throw (c2_exception)</td></tr>
<tr class="memdesc:aea75f73d6a97087571c163ae4e514652"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a <a class="el" href="classc2__piecewise__function__p.html" title="create a c2_function which is a piecewise assembly of other c2_functions.The functions must have incr...">c2_piecewise_function_p</a> from <a class="el" href="classc2__connector__function__p.html" title="create a c2_function which smoothly connects two other c2_functions.This takes two points and generat...">c2_connector_function_p</a> segments which is a representation of the parent function to the specified accuracy, but maybe much cheaper to evaluate  <a href="#aea75f73d6a97087571c163ae4e514652">More...</a><br/></td></tr>
<tr class="separator:aea75f73d6a97087571c163ae4e514652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acddff2d033c7f3205658e246d806204b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acddff2d033c7f3205658e246d806204b"></a>
float_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc2__function.html#acddff2d033c7f3205658e246d806204b">xmin</a> () const </td></tr>
<tr class="memdesc:acddff2d033c7f3205658e246d806204b"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the lower bound of the domain for this function as set by <a class="el" href="classc2__function.html#adeb70da9c75011e9abd71142dca4c22e" title="set the domain for this function. ">set_domain()</a> <br/></td></tr>
<tr class="separator:acddff2d033c7f3205658e246d806204b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f3ac790b6659b2d137f4c90eadb6ef0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7f3ac790b6659b2d137f4c90eadb6ef0"></a>
float_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc2__function.html#a7f3ac790b6659b2d137f4c90eadb6ef0">xmax</a> () const </td></tr>
<tr class="memdesc:a7f3ac790b6659b2d137f4c90eadb6ef0"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the upper bound of the domain for this function as set by <a class="el" href="classc2__function.html#adeb70da9c75011e9abd71142dca4c22e" title="set the domain for this function. ">set_domain()</a> <br/></td></tr>
<tr class="separator:a7f3ac790b6659b2d137f4c90eadb6ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeb70da9c75011e9abd71142dca4c22e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adeb70da9c75011e9abd71142dca4c22e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc2__function.html#adeb70da9c75011e9abd71142dca4c22e">set_domain</a> (float_type amin, float_type amax)</td></tr>
<tr class="memdesc:adeb70da9c75011e9abd71142dca4c22e"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the domain for this function. <br/></td></tr>
<tr class="separator:adeb70da9c75011e9abd71142dca4c22e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6ff0c597019dfb38b1d3d76bfd71e6c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc2__function.html#ab6ff0c597019dfb38b1d3d76bfd71e6c">get_evaluations</a> () const </td></tr>
<tr class="memdesc:ab6ff0c597019dfb38b1d3d76bfd71e6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">this is a counter owned by the function but which can be used to monitor efficiency of algorithms.  <a href="#ab6ff0c597019dfb38b1d3d76bfd71e6c">More...</a><br/></td></tr>
<tr class="separator:ab6ff0c597019dfb38b1d3d76bfd71e6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8003c40247b7255de5ffbcd3ec21e395"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8003c40247b7255de5ffbcd3ec21e395"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc2__function.html#a8003c40247b7255de5ffbcd3ec21e395">reset_evaluations</a> () const </td></tr>
<tr class="memdesc:a8003c40247b7255de5ffbcd3ec21e395"><td class="mdescLeft">&#160;</td><td class="mdescRight">reset the counter <br/></td></tr>
<tr class="separator:a8003c40247b7255de5ffbcd3ec21e395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43555fd6a4ce48f5739e16483170c096"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a43555fd6a4ce48f5739e16483170c096"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc2__function.html#a43555fd6a4ce48f5739e16483170c096">increment_evaluations</a> () const </td></tr>
<tr class="memdesc:a43555fd6a4ce48f5739e16483170c096"><td class="mdescLeft">&#160;</td><td class="mdescRight">count evaluations <br/></td></tr>
<tr class="separator:a43555fd6a4ce48f5739e16483170c096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fffb02df5bbff25b0fde67115eae196"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc2__function.html#a8fffb02df5bbff25b0fde67115eae196">check_monotonicity</a> (const std::vector&lt; float_type &gt; &amp;data, const char message[]) const   throw (c2_exception)</td></tr>
<tr class="memdesc:a8fffb02df5bbff25b0fde67115eae196"><td class="mdescLeft">&#160;</td><td class="mdescRight">check that a vector is monotonic, throw an exception if not, and return a flag if it is reversed  <a href="#a8fffb02df5bbff25b0fde67115eae196">More...</a><br/></td></tr>
<tr class="separator:a8fffb02df5bbff25b0fde67115eae196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23828c75121b442899ab7a80cf5abbb0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc2__function.html#a23828c75121b442899ab7a80cf5abbb0">set_sampling_grid</a> (const std::vector&lt; float_type &gt; &amp;grid)  throw (c2_exception)</td></tr>
<tr class="memdesc:a23828c75121b442899ab7a80cf5abbb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">establish a grid of 'interesting' points on the function.  <a href="#a23828c75121b442899ab7a80cf5abbb0">More...</a><br/></td></tr>
<tr class="separator:a23828c75121b442899ab7a80cf5abbb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b0427521403da116691bab7695906a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; float_type &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc2__function.html#a78b0427521403da116691bab7695906a">get_sampling_grid_pointer</a> () const </td></tr>
<tr class="memdesc:a78b0427521403da116691bab7695906a"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the sampling grid, which may be a null pointer  <a href="#a78b0427521403da116691bab7695906a">More...</a><br/></td></tr>
<tr class="separator:a78b0427521403da116691bab7695906a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad03264dcc015e5d0b1b6eb30df3f32be"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc2__function.html#ad03264dcc015e5d0b1b6eb30df3f32be">get_sampling_grid</a> (float_type amin, float_type amax, std::vector&lt; float_type &gt; &amp;grid) const </td></tr>
<tr class="memdesc:ad03264dcc015e5d0b1b6eb30df3f32be"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the grid of 'interesting' points along this function which lie in the region requested  <a href="#ad03264dcc015e5d0b1b6eb30df3f32be">More...</a><br/></td></tr>
<tr class="separator:ad03264dcc015e5d0b1b6eb30df3f32be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f461317f09a62101e6114fd693fa20c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc2__function.html#a3f461317f09a62101e6114fd693fa20c">preen_sampling_grid</a> (std::vector&lt; float_type &gt; *result) const </td></tr>
<tr class="memdesc:a3f461317f09a62101e6114fd693fa20c"><td class="mdescLeft">&#160;</td><td class="mdescRight">clean up endpoints on a grid of points  <a href="#a3f461317f09a62101e6114fd693fa20c">More...</a><br/></td></tr>
<tr class="separator:a3f461317f09a62101e6114fd693fa20c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25004cf23f56fafd0b64901354892f3c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc2__function.html#a25004cf23f56fafd0b64901354892f3c">refine_sampling_grid</a> (std::vector&lt; float_type &gt; &amp;grid, size_t refinement) const </td></tr>
<tr class="memdesc:a25004cf23f56fafd0b64901354892f3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">refine a grid by splitting each interval into more intervals  <a href="#a25004cf23f56fafd0b64901354892f3c">More...</a><br/></td></tr>
<tr class="separator:a25004cf23f56fafd0b64901354892f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad908929d3a8d8022caf4f3f1c65d5e71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classc2__function.html">c2_function</a>&lt; float_type &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc2__function.html#ad908929d3a8d8022caf4f3f1c65d5e71">normalized_function</a> (float_type amin, float_type amax, float_type norm=1.0) const   throw (c2_exception)</td></tr>
<tr class="memdesc:ad908929d3a8d8022caf4f3f1c65d5e71"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a new <a class="el" href="classc2__function.html" title="the parent class for all c2_functions.c2_functions know their value, first, and second derivative at ...">c2_function</a> from this one which is normalized on the interval  <a href="#ad908929d3a8d8022caf4f3f1c65d5e71">More...</a><br/></td></tr>
<tr class="separator:ad908929d3a8d8022caf4f3f1c65d5e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcf8bcc841ca3a1155ae115178ea88af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classc2__function.html">c2_function</a>&lt; float_type &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc2__function.html#adcf8bcc841ca3a1155ae115178ea88af">square_normalized_function</a> (float_type amin, float_type amax, float_type norm=1.0) const   throw (c2_exception)</td></tr>
<tr class="memdesc:adcf8bcc841ca3a1155ae115178ea88af"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a new <a class="el" href="classc2__function.html" title="the parent class for all c2_functions.c2_functions know their value, first, and second derivative at ...">c2_function</a> from this one which is square-normalized on the interval  <a href="#adcf8bcc841ca3a1155ae115178ea88af">More...</a><br/></td></tr>
<tr class="separator:adcf8bcc841ca3a1155ae115178ea88af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d8716e8abb9e02a188c243f825acf9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classc2__function.html">c2_function</a>&lt; float_type &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc2__function.html#a9d8716e8abb9e02a188c243f825acf9b">square_normalized_function</a> (float_type amin, float_type amax, const <a class="el" href="classc2__function.html">c2_function</a>&lt; float_type &gt; &amp;weight, float_type norm=1.0) const   throw (c2_exception)</td></tr>
<tr class="memdesc:a9d8716e8abb9e02a188c243f825acf9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a new <a class="el" href="classc2__function.html" title="the parent class for all c2_functions.c2_functions know their value, first, and second derivative at ...">c2_function</a> from this one which is square-normalized with the provided <em>weight</em> on the interval  <a href="#a9d8716e8abb9e02a188c243f825acf9b">More...</a><br/></td></tr>
<tr class="separator:a9d8716e8abb9e02a188c243f825acf9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a268b206b47c55e635e5f0a9e0f3e8ded"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classc2__sum__p.html">c2_sum_p</a>&lt; float_type &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc2__function.html#a268b206b47c55e635e5f0a9e0f3e8ded">operator+</a> (const <a class="el" href="classc2__function.html">c2_function</a>&lt; float_type &gt; &amp;rhs) const </td></tr>
<tr class="memdesc:a268b206b47c55e635e5f0a9e0f3e8ded"><td class="mdescLeft">&#160;</td><td class="mdescRight">factory function to create a <a class="el" href="classc2__sum__p.html" title="create a c2_function which is the sum of two other c2_function objects.This should always be construc...">c2_sum_p</a> from a regular algebraic expression.  <a href="#a268b206b47c55e635e5f0a9e0f3e8ded">More...</a><br/></td></tr>
<tr class="separator:a268b206b47c55e635e5f0a9e0f3e8ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c56a4673e00bfad37143c403a0c94c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classc2__diff__p.html">c2_diff_p</a>&lt; float_type &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc2__function.html#a4c56a4673e00bfad37143c403a0c94c8">operator-</a> (const <a class="el" href="classc2__function.html">c2_function</a>&lt; float_type &gt; &amp;rhs) const </td></tr>
<tr class="memdesc:a4c56a4673e00bfad37143c403a0c94c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">factory function to create a <a class="el" href="classc2__diff__p.html" title="create a c2_function which is the difference of two other c2_functions.This should always be construc...">c2_diff_p</a> from a regular algebraic expression.  <a href="#a4c56a4673e00bfad37143c403a0c94c8">More...</a><br/></td></tr>
<tr class="separator:a4c56a4673e00bfad37143c403a0c94c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7744675c98a8ec63320ac1c0b61bec9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classc2__product__p.html">c2_product_p</a>&lt; float_type &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc2__function.html#a7744675c98a8ec63320ac1c0b61bec9c">operator*</a> (const <a class="el" href="classc2__function.html">c2_function</a>&lt; float_type &gt; &amp;rhs) const </td></tr>
<tr class="memdesc:a7744675c98a8ec63320ac1c0b61bec9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">factory function to create a <a class="el" href="classc2__product__p.html" title="create a c2_function which is the product of two other c2_functions.This should always be constructed...">c2_product_p</a> from a regular algebraic expression.  <a href="#a7744675c98a8ec63320ac1c0b61bec9c">More...</a><br/></td></tr>
<tr class="separator:a7744675c98a8ec63320ac1c0b61bec9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93ac28dfe5daebea84d147b8e346e60c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classc2__ratio__p.html">c2_ratio_p</a>&lt; float_type &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc2__function.html#a93ac28dfe5daebea84d147b8e346e60c">operator/</a> (const <a class="el" href="classc2__function.html">c2_function</a>&lt; float_type &gt; &amp;rhs) const </td></tr>
<tr class="memdesc:a93ac28dfe5daebea84d147b8e346e60c"><td class="mdescLeft">&#160;</td><td class="mdescRight">factory function to create a <a class="el" href="classc2__ratio__p.html" title="create a c2_function which is the ratio of two other c2_functions.This should always be constructed u...">c2_ratio_p</a> from a regular algebraic expression.  <a href="#a93ac28dfe5daebea84d147b8e346e60c">More...</a><br/></td></tr>
<tr class="separator:a93ac28dfe5daebea84d147b8e346e60c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9332f7b389579a9b03eb57578649e07f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classc2__composed__function__p.html">c2_composed_function_p</a><br class="typebreak"/>
&lt; float_type &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc2__function.html#a9332f7b389579a9b03eb57578649e07f">operator()</a> (const <a class="el" href="classc2__function.html">c2_function</a>&lt; float_type &gt; &amp;inner) const </td></tr>
<tr class="memdesc:a9332f7b389579a9b03eb57578649e07f"><td class="mdescLeft">&#160;</td><td class="mdescRight">compose this function outside another.  <a href="#a9332f7b389579a9b03eb57578649e07f">More...</a><br/></td></tr>
<tr class="separator:a9332f7b389579a9b03eb57578649e07f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e575976851a0b93a9dc2803b4ac2123"><td class="memItemLeft" align="right" valign="top">float_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc2__function.html#a8e575976851a0b93a9dc2803b4ac2123">get_trouble_point</a> () const </td></tr>
<tr class="memdesc:a8e575976851a0b93a9dc2803b4ac2123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find out where a calculation ran into trouble, if it got a nan. If the most recent computation did not return a nan, this is undefined.  <a href="#a8e575976851a0b93a9dc2803b4ac2123">More...</a><br/></td></tr>
<tr class="separator:a8e575976851a0b93a9dc2803b4ac2123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd32e22d0b47878dc9fb399a722db61e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd32e22d0b47878dc9fb399a722db61e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc2__function.html#acd32e22d0b47878dc9fb399a722db61e">claim_ownership</a> () const </td></tr>
<tr class="memdesc:acd32e22d0b47878dc9fb399a722db61e"><td class="mdescLeft">&#160;</td><td class="mdescRight">increment our reference count. Destruction is only legal if the count is zero. <br/></td></tr>
<tr class="separator:acd32e22d0b47878dc9fb399a722db61e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af003b3e29357ccf65b7eba38be877b8c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc2__function.html#af003b3e29357ccf65b7eba38be877b8c">release_ownership_for_return</a> () const   throw (c2_exception)</td></tr>
<tr class="memdesc:af003b3e29357ccf65b7eba38be877b8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">decrement our reference count. Do not destroy at zero.  <a href="#af003b3e29357ccf65b7eba38be877b8c">More...</a><br/></td></tr>
<tr class="separator:af003b3e29357ccf65b7eba38be877b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac98aa40f78c487df141a67174662d749"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac98aa40f78c487df141a67174662d749"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc2__function.html#ac98aa40f78c487df141a67174662d749">release_ownership</a> () const   throw (c2_exception)</td></tr>
<tr class="memdesc:ac98aa40f78c487df141a67174662d749"><td class="mdescLeft">&#160;</td><td class="mdescRight">decrement our reference count. If the count reaches zero, destroy ourself. <br/></td></tr>
<tr class="separator:ac98aa40f78c487df141a67174662d749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1df932c78b3521d6a4493972f2642020"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc2__function.html#a1df932c78b3521d6a4493972f2642020">count_owners</a> () const </td></tr>
<tr class="memdesc:a1df932c78b3521d6a4493972f2642020"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the reference count, mostly for debugging  <a href="#a1df932c78b3521d6a4493972f2642020">More...</a><br/></td></tr>
<tr class="separator:a1df932c78b3521d6a4493972f2642020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdce52d0b89ff5bde13d9390ff8c2ba4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc2__function.html#abdce52d0b89ff5bde13d9390ff8c2ba4">fill_fblock</a> (<a class="el" href="classc2__fblock.html">c2_fblock</a>&lt; float_type &gt; &amp;fb) const   throw (c2_exception)</td></tr>
<tr class="memdesc:abdce52d0b89ff5bde13d9390ff8c2ba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">fill in a c2_fblock&lt;float_type&gt;... a shortcut for the integrator &amp; sampler  <a href="#abdce52d0b89ff5bde13d9390ff8c2ba4">More...</a><br/></td></tr>
<tr class="separator:abdce52d0b89ff5bde13d9390ff8c2ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a0dcc0aa8129ea37e46a72bcafd5d1dc3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0dcc0aa8129ea37e46a72bcafd5d1dc3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>c2_function</b> (const <a class="el" href="classc2__function.html">c2_function</a>&lt; float_type &gt; &amp;src)</td></tr>
<tr class="separator:a0dcc0aa8129ea37e46a72bcafd5d1dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af06d3b95c044d5ece8343badec919d17"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af06d3b95c044d5ece8343badec919d17"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>set_sampling_grid_pointer</b> (std::vector&lt; float_type &gt; &amp;grid)</td></tr>
<tr class="separator:af06d3b95c044d5ece8343badec919d17"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ad9714faf2c3d053a77fd733b52834754"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad9714faf2c3d053a77fd733b52834754"></a>
std::vector&lt; float_type &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>sampling_grid</b></td></tr>
<tr class="separator:ad9714faf2c3d053a77fd733b52834754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12085ddfc5716c442bb59c5672e140dd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a12085ddfc5716c442bb59c5672e140dd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>no_overwrite_grid</b></td></tr>
<tr class="separator:a12085ddfc5716c442bb59c5672e140dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72d60216e8a9c61039d4895c6a15b0ce"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a72d60216e8a9c61039d4895c6a15b0ce"></a>
float_type&#160;</td><td class="memItemRight" valign="bottom"><b>fXMin</b></td></tr>
<tr class="separator:a72d60216e8a9c61039d4895c6a15b0ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d000a2d3ca13a119f4bcf4e31a9bca6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d000a2d3ca13a119f4bcf4e31a9bca6"></a>
float_type&#160;</td><td class="memItemRight" valign="bottom"><b>fXMax</b></td></tr>
<tr class="separator:a8d000a2d3ca13a119f4bcf4e31a9bca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0737663eb36818cd357852479e6b96f2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0737663eb36818cd357852479e6b96f2"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>evaluations</b></td></tr>
<tr class="separator:a0737663eb36818cd357852479e6b96f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19b31dd52b778a2fe5f156def38e41d4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a19b31dd52b778a2fe5f156def38e41d4"></a>
float_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc2__function.html#a19b31dd52b778a2fe5f156def38e41d4">bad_x_point</a></td></tr>
<tr class="memdesc:a19b31dd52b778a2fe5f156def38e41d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">this point may be used to record where a calculation ran into trouble <br/></td></tr>
<tr class="separator:a19b31dd52b778a2fe5f156def38e41d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename float_type = double&gt;<br/>
class c2_function&lt; float_type &gt;</h3>

<p>the parent class for all c2_functions.</p>
<p>c2_functions know their value, first, and second derivative at almost every point. They can be efficiently combined with binary operators, via <a class="el" href="classc2__binary__function.html" title="Provides support for c2_function objects which are constructed from two other c2_function objects...">c2_binary_function</a>, composed via c2_composed_function_, have their roots found via <a class="el" href="classc2__function.html#acd17a7191226578c866d82cb2e9ff89f" title="solve f(x)==value very efficiently, with explicit knowledge of derivatives of the function ...">find_root()</a>, and be adaptively integrated via <a class="el" href="classc2__function.html#a89ce5e2f44ebfaf9eb4d66605cde4fde" title="for points in xgrid, adaptively return Integral[f(x),{x,xgrid[i],xgrid[i+1]}] and return in vector...">partial_integrals()</a> or <a class="el" href="classc2__function.html#a675c5056562332be2e49b38485d322b7" title="a fully-automated integrator which uses the information provided by the get_sampling_grid() function ...">integral()</a>. They also can carry information with them about how to find 'interesting' points on the function. This information is set with <a class="el" href="classc2__function.html#a23828c75121b442899ab7a80cf5abbb0" title="establish a grid of &#39;interesting&#39; points on the function. ">set_sampling_grid()</a> and extracted with <a class="el" href="classc2__function.html#ad03264dcc015e5d0b1b6eb30df3f32be" title="return the grid of &#39;interesting&#39; points along this function which lie in the region requested ...">get_sampling_grid()</a>. </p>
<p>Particularly important subclasses are the interpolating functions classes, interpolating_function , lin_log_interpolating_function, log_lin_interpolating_function, log_log_interpolating_function, and arrhenius_interpolating_function, as well as the template functions inverse_integrated_density_function().</p>
<p>For a discussion of memory management, see memory_management </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aea75f73d6a97087571c163ae4e514652"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename float_type = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classc2__piecewise__function__p.html">c2_piecewise_function_p</a>&lt;float_type&gt;* <a class="el" href="classc2__function.html">c2_function</a>&lt; float_type &gt;::adaptively_sample </td>
          <td>(</td>
          <td class="paramtype">float_type&#160;</td>
          <td class="paramname"><em>amin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_type&#160;</td>
          <td class="paramname"><em>amax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_type&#160;</td>
          <td class="paramname"><em>abs_tol</em> = <code>1e-12</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_type&#160;</td>
          <td class="paramname"><em>rel_tol</em> = <code>1e-12</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>derivs</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; float_type &gt; *&#160;</td>
          <td class="paramname"><em>xvals</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; float_type &gt; *&#160;</td>
          <td class="paramname"><em>yvals</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"><a class="el" href="classc2__exception.html">c2_exception</a></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a <a class="el" href="classc2__piecewise__function__p.html" title="create a c2_function which is a piecewise assembly of other c2_functions.The functions must have incr...">c2_piecewise_function_p</a> from <a class="el" href="classc2__connector__function__p.html" title="create a c2_function which smoothly connects two other c2_functions.This takes two points and generat...">c2_connector_function_p</a> segments which is a representation of the parent function to the specified accuracy, but maybe much cheaper to evaluate </p>
<p>This method has three modes, depending on the <em>derivs</em> flag.</p>
<p>If <em>derivs</em> is 2, it computes a <a class="el" href="classc2__piecewise__function__p.html" title="create a c2_function which is a piecewise assembly of other c2_functions.The functions must have incr...">c2_piecewise_function_p</a> representation of its parent function, which may be a much faster function to use in codes if the parent function is expensive. If <em>xvals</em> and <em>yvals</em> are non-null, it will also fill them in with the function values at each grid point the adaptive algorithm chooses.</p>
<p>If <em>derivs</em> is 1, this does not create the connectors, and returns an null pointer, but will fill in the <em>xvals</em> and <em>yvals</em> vectors with values of the function at points such that the linear interpolation error between the points is bounded by the tolerance values given. Because it uses derivative information from the function to manage the error control, it is almost completely free of issues with missing periods of oscillatory functions, even with no information provided in the sampling grid. This is typically useful for sampling a function for plotting.</p>
<p>If <em>derivs</em> is 0, this does something very like what it does if <em>derivs</em> = 1, but without derivatives. Instead, to compute the intermediate value of the function for error control, it just uses 3-point parabolic interpolation. This is useful amost exclusively for converting a non-c2_function, with no derivatives, but wrapped in a c2_classic_function wrapper, into a table of values to seed an <a class="el" href="classinterpolating__function__p.html" title="create a cubic spline interpolation of a set of (x,y) pairsThis is one of the main reasons for c2_fun...">interpolating_function_p</a>. Note, however, that without derivatives, this is very susceptible to missing periods of oscillatory functions, so it is important to set a sampling grid which isn't too much coarser than the typical oscillations.</p>
<dl class="section note"><dt>Note</dt><dd>the <em>sampling_grid</em> of the returned function matches the <em>sampling_grid</em> of its parent. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd>Adaptive Sampling Examples </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">amin</td><td>lower bound of the domain for sampling </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">amax</td><td>upper bound of the domain for sampling </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">abs_tol</td><td>the absolute error bound for each segment </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">rel_tol</td><td>the fractional error bound for each segment. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">derivs</td><td>if 0 or 1, return a useless function, but fill in the <em>xvals</em> and <em>yvals</em> vectors (if non-null). Also, if 0 or 1, tolerances refer to linear interpolation, not high-order interpolation. If 2, return a full piecewise collection of <a class="el" href="classc2__connector__function__p.html" title="create a c2_function which smoothly connects two other c2_functions.This takes two points and generat...">c2_connector_function_p</a> segments. See discussion above. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">xvals</td><td>vector of abscissas at which the function was actually sampled (if non-null) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">yvals</td><td>vector of function values corresponding to <em>xvals</em> (if non-null) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new, sampled representation, if <em>derivs</em> is 2. A null pointer if <em>derivs</em> is 0 or 1. </dd></dl>

</div>
</div>
<a class="anchor" id="a8fffb02df5bbff25b0fde67115eae196"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename float_type = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classc2__function.html">c2_function</a>&lt; float_type &gt;::check_monotonicity </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; float_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>message</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"><a class="el" href="classc2__exception.html">c2_exception</a></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>check that a vector is monotonic, throw an exception if not, and return a flag if it is reversed </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>a vector of data points which are expected to be monotonic. </td></tr>
    <tr><td class="paramname">message</td><td>an informative string to include in an exception if this throws <a class="el" href="classc2__exception.html" title="the exception class for c2_function operations. ">c2_exception</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if in decreasing order, false if increasing </dd></dl>

</div>
</div>
<a class="anchor" id="a1df932c78b3521d6a4493972f2642020"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename float_type = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classc2__function.html">c2_function</a>&lt; float_type &gt;::count_owners </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the reference count, mostly for debugging </p>
<dl class="section return"><dt>Returns</dt><dd>the count </dd></dl>

</div>
</div>
<a class="anchor" id="a2304b7543724be829571336da02b0f91"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename float_type = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::string <a class="el" href="classc2__function.html">c2_function</a>&lt; float_type &gt;::cvs_file_vers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get versioning information for the source file </p>
<dl class="section return"><dt>Returns</dt><dd>the CVS Id string </dd></dl>

</div>
</div>
<a class="anchor" id="a851a9e8dca6e8fa9c2da12c8705566b2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename float_type = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string <a class="el" href="classc2__function.html">c2_function</a>&lt; float_type &gt;::cvs_header_vers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get versioning information for the header file </p>
<dl class="section return"><dt>Returns</dt><dd>the CVS Id string </dd></dl>

</div>
</div>
<a class="anchor" id="abdce52d0b89ff5bde13d9390ff8c2ba4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename float_type = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classc2__function.html">c2_function</a>&lt; float_type &gt;::fill_fblock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classc2__fblock.html">c2_fblock</a>&lt; float_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>fb</em></td><td>)</td>
          <td> const</td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"><a class="el" href="classc2__exception.html">c2_exception</a></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>fill in a c2_fblock&lt;float_type&gt;... a shortcut for the integrator &amp; sampler </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">fb</td><td>the block to fill in with information </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acd17a7191226578c866d82cb2e9ff89f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename float_type = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">float_type <a class="el" href="classc2__function.html">c2_function</a>&lt; float_type &gt;::find_root </td>
          <td>(</td>
          <td class="paramtype">float_type&#160;</td>
          <td class="paramname"><em>lower_bracket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_type&#160;</td>
          <td class="paramname"><em>upper_bracket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_type&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_type&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>error</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_type *&#160;</td>
          <td class="paramname"><em>final_yprime</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_type *&#160;</td>
          <td class="paramname"><em>final_yprime2</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"><a class="el" href="classc2__exception.html">c2_exception</a></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>solve f(x)==value very efficiently, with explicit knowledge of derivatives of the function </p>
<p>find_root solves by iterated inverse quadratic extrapolation for a solution to f(x)=y. It includes checks against bad convergence, so it should never be able to fail. Unlike typical secant method or fancier Brent's method finders, this does not depend in any strong wasy on the brackets, unless the finder has to resort to successive approximations to close in on a root. Often, it is possible to make the brackets equal to the domain of the function, if there is any clue as to where the root lies, as given by the parameter <em>start</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">lower_bracket</td><td>the lower bound for the search </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">upper_bracket</td><td>the upper bound for the search. Function sign must be opposite to that at <em>lower_bracket</em> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">start</td><td>starting value for the search </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">value</td><td>the value of the function being sought (solves f(x) = <em>value</em>) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">error</td><td>If pointer is zero, errors raise exception. Otherwise, returns error here. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">final_yprime</td><td>If pointer is not zero, return derivative of function at root </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">final_yprime2</td><td>If pointer is not zero, return second derivative of function at root </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the position of the root. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd>Root finding sample </dd></dl>

</div>
</div>
<a class="anchor" id="ab6ff0c597019dfb38b1d3d76bfd71e6c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename float_type = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classc2__function.html">c2_function</a>&lt; float_type &gt;::get_evaluations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>this is a counter owned by the function but which can be used to monitor efficiency of algorithms. </p>
<p>It is not maintained automatically in general! The root finder, integrator, and sampler do increment it. </p>
<dl class="section return"><dt>Returns</dt><dd>number of evaluations logged since last reset. </dd></dl>

</div>
</div>
<a class="anchor" id="ad03264dcc015e5d0b1b6eb30df3f32be"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename float_type = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classc2__function.html">c2_function</a>&lt; float_type &gt;::get_sampling_grid </td>
          <td>(</td>
          <td class="paramtype">float_type&#160;</td>
          <td class="paramname"><em>amin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_type&#160;</td>
          <td class="paramname"><em>amax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; float_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>grid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the grid of 'interesting' points along this function which lie in the region requested </p>
<p>if a sampling grid is defined, work from there, otherwise return vector of (amin, amax) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">amin</td><td>the lower bound for which the function is to be sampled </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">amax</td><td>the upper bound for which the function is to be sampled </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">grid</td><td>filled vector containing the samplng grid. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classc2__sin__p.html#a24cee8161741bd4a4dbb24dd782514c1">c2_sin_p&lt; float_type &gt;</a>, <a class="el" href="classc2__plugin__function__p.html#a0e7ff48329a648b3966efba72b15e3ed">c2_plugin_function_p&lt; float_type &gt;</a>, and <a class="el" href="classc2__plugin__function__p.html#a0e7ff48329a648b3966efba72b15e3ed">c2_plugin_function_p&lt; G4double &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a78b0427521403da116691bab7695906a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename float_type = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;float_type&gt;* <a class="el" href="classc2__function.html">c2_function</a>&lt; float_type &gt;::get_sampling_grid_pointer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the sampling grid, which may be a null pointer </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to the sampling grid </dd></dl>

</div>
</div>
<a class="anchor" id="a8e575976851a0b93a9dc2803b4ac2123"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename float_type = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float_type <a class="el" href="classc2__function.html">c2_function</a>&lt; float_type &gt;::get_trouble_point </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find out where a calculation ran into trouble, if it got a nan. If the most recent computation did not return a nan, this is undefined. </p>
<dl class="section return"><dt>Returns</dt><dd><em>x</em> value of point at which something went wrong, if integrator (or otherwise) returned a nan. </dd></dl>

</div>
</div>
<a class="anchor" id="a675c5056562332be2e49b38485d322b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename float_type = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">float_type <a class="el" href="classc2__function.html">c2_function</a>&lt; float_type &gt;::integral </td>
          <td>(</td>
          <td class="paramtype">float_type&#160;</td>
          <td class="paramname"><em>amin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_type&#160;</td>
          <td class="paramname"><em>amax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; float_type &gt; *&#160;</td>
          <td class="paramname"><em>partials</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_type&#160;</td>
          <td class="paramname"><em>abs_tol</em> = <code>1e-12</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_type&#160;</td>
          <td class="paramname"><em>rel_tol</em> = <code>1e-12</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>derivs</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>adapt</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>extrapolate</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"><a class="el" href="classc2__exception.html">c2_exception</a></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a fully-automated integrator which uses the information provided by the <a class="el" href="classc2__function.html#ad03264dcc015e5d0b1b6eb30df3f32be" title="return the grid of &#39;interesting&#39; points along this function which lie in the region requested ...">get_sampling_grid()</a> function to figure out what to do. </p>
<p>It returns the integral of the function over the domain requested with error tolerances as specified. It is just a front-end to <a class="el" href="classc2__function.html#a89ce5e2f44ebfaf9eb4d66605cde4fde" title="for points in xgrid, adaptively return Integral[f(x),{x,xgrid[i],xgrid[i+1]}] and return in vector...">partial_integrals()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">amin</td><td>lower bound of the domain for integration </td></tr>
    <tr><td class="paramname">amax</td><td>upper bound of the domain for integration </td></tr>
    <tr><td class="paramname">partials</td><td>if non-NULL, a vector in which to receive the partial integrals. It will automatically be sized appropriately, if provided, to contain <em>n</em> - 1 elements where <em>n</em> is the length of <em>xgrid</em> </td></tr>
    <tr><td class="paramname">abs_tol</td><td>the absolute error bound for each segment </td></tr>
    <tr><td class="paramname">rel_tol</td><td>the fractional error bound for each segment. If the error is smaller than either the relative or absolute tolerance, the integration step is finished. </td></tr>
    <tr><td class="paramname">derivs</td><td>number of derivatives to trust, which sets the order of the integrator. The order is 3*<em>derivs</em> + 4. <em>derivs</em> can be 0, 1, or 2. </td></tr>
    <tr><td class="paramname">adapt</td><td>if true, use recursive adaptation, otherwise do simple evaluation on the grid provided with no error checking. </td></tr>
    <tr><td class="paramname">extrapolate</td><td>if true, use simple Richardson extrapolation on the final 2 steps to reduce the error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sum of partial integrals, which is the definite integral from the first value in <em>xgrid</em> to the last. </dd></dl>

</div>
</div>
<a class="anchor" id="ad908929d3a8d8022caf4f3f1c65d5e71"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename float_type = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classc2__function.html">c2_function</a>&lt;float_type&gt;&amp; <a class="el" href="classc2__function.html">c2_function</a>&lt; float_type &gt;::normalized_function </td>
          <td>(</td>
          <td class="paramtype">float_type&#160;</td>
          <td class="paramname"><em>amin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_type&#160;</td>
          <td class="paramname"><em>amax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_type&#160;</td>
          <td class="paramname"><em>norm</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"><a class="el" href="classc2__exception.html">c2_exception</a></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a new <a class="el" href="classc2__function.html" title="the parent class for all c2_functions.c2_functions know their value, first, and second derivative at ...">c2_function</a> from this one which is normalized on the interval </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">amin</td><td>lower bound of the domain for integration </td></tr>
    <tr><td class="paramname">amax</td><td>upper bound of the domain for integration </td></tr>
    <tr><td class="paramname">norm</td><td>the desired integral for the function over the region </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new <a class="el" href="classc2__function.html" title="the parent class for all c2_functions.c2_functions know their value, first, and second derivative at ...">c2_function</a> with the desired <em>norm</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="a0658cb22966f0ff9072d4d0e04b54c61"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename float_type = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float_type <a class="el" href="classc2__function.html">c2_function</a>&lt; float_type &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">float_type&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"><a class="el" href="classc2__exception.html">c2_exception</a></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>evaluate the function in the classic way, ignoring derivatives. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the point at which to evaluate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the function </dd></dl>

</div>
</div>
<a class="anchor" id="a25c89b64e6cbd749314d0a61063240cc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename float_type = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float_type <a class="el" href="classc2__function.html">c2_function</a>&lt; float_type &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">float_type&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_type *&#160;</td>
          <td class="paramname"><em>yprime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_type *&#160;</td>
          <td class="paramname"><em>yprime2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"><a class="el" href="classc2__exception.html">c2_exception</a></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the value and derivatives. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>the point at which to evaluate the function </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">yprime</td><td>the first derivative (if pointer is non-null) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">yprime2</td><td>the second derivative (if pointer is non-null) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the function </dd></dl>

</div>
</div>
<a class="anchor" id="a9332f7b389579a9b03eb57578649e07f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename float_type = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classc2__composed__function__p.html">c2_composed_function_p</a>&lt;float_type&gt;&amp; <a class="el" href="classc2__function.html">c2_function</a>&lt; float_type &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classc2__function.html">c2_function</a>&lt; float_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>inner</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compose this function outside another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inner</td><td>the inner function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the composed function <a class="anchor" id="compose_operator"></a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7744675c98a8ec63320ac1c0b61bec9c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename float_type = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classc2__product__p.html">c2_product_p</a>&lt;float_type&gt;&amp; <a class="el" href="classc2__function.html">c2_function</a>&lt; float_type &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classc2__function.html">c2_function</a>&lt; float_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>factory function to create a <a class="el" href="classc2__product__p.html" title="create a c2_function which is the product of two other c2_functions.This should always be constructed...">c2_product_p</a> from a regular algebraic expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the right-hand term of the product </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new <a class="el" href="classc2__function.html" title="the parent class for all c2_functions.c2_functions know their value, first, and second derivative at ...">c2_function</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a268b206b47c55e635e5f0a9e0f3e8ded"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename float_type = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classc2__sum__p.html">c2_sum_p</a>&lt;float_type&gt;&amp; <a class="el" href="classc2__function.html">c2_function</a>&lt; float_type &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classc2__function.html">c2_function</a>&lt; float_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>factory function to create a <a class="el" href="classc2__sum__p.html" title="create a c2_function which is the sum of two other c2_function objects.This should always be construc...">c2_sum_p</a> from a regular algebraic expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the right-hand term of the sum </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new <a class="el" href="classc2__function.html" title="the parent class for all c2_functions.c2_functions know their value, first, and second derivative at ...">c2_function</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4c56a4673e00bfad37143c403a0c94c8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename float_type = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classc2__diff__p.html">c2_diff_p</a>&lt;float_type&gt;&amp; <a class="el" href="classc2__function.html">c2_function</a>&lt; float_type &gt;::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classc2__function.html">c2_function</a>&lt; float_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>factory function to create a <a class="el" href="classc2__diff__p.html" title="create a c2_function which is the difference of two other c2_functions.This should always be construc...">c2_diff_p</a> from a regular algebraic expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the right-hand term of the difference </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new <a class="el" href="classc2__function.html" title="the parent class for all c2_functions.c2_functions know their value, first, and second derivative at ...">c2_function</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a93ac28dfe5daebea84d147b8e346e60c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename float_type = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classc2__ratio__p.html">c2_ratio_p</a>&lt;float_type&gt;&amp; <a class="el" href="classc2__function.html">c2_function</a>&lt; float_type &gt;::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classc2__function.html">c2_function</a>&lt; float_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>factory function to create a <a class="el" href="classc2__ratio__p.html" title="create a c2_function which is the ratio of two other c2_functions.This should always be constructed u...">c2_ratio_p</a> from a regular algebraic expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the right-hand term of the ratio (the denominator) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new <a class="el" href="classc2__function.html" title="the parent class for all c2_functions.c2_functions know their value, first, and second derivative at ...">c2_function</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a89ce5e2f44ebfaf9eb4d66605cde4fde"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename float_type = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">float_type <a class="el" href="classc2__function.html">c2_function</a>&lt; float_type &gt;::partial_integrals </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; float_type &gt;&#160;</td>
          <td class="paramname"><em>xgrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; float_type &gt; *&#160;</td>
          <td class="paramname"><em>partials</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_type&#160;</td>
          <td class="paramname"><em>abs_tol</em> = <code>1e-12</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_type&#160;</td>
          <td class="paramname"><em>rel_tol</em> = <code>1e-12</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>derivs</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>adapt</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>extrapolate</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"><a class="el" href="classc2__exception.html">c2_exception</a></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>for points in xgrid, adaptively return Integral[f(x),{x,xgrid[i],xgrid[i+1]}] and return in vector, along with sum </p>
<p>partial_integrals uses a method with an error O(dx**10) with full information from the derivatives, and falls back to lower order methods if informed of incomplete derivatives. It uses exact midpoint splitting of the intervals for recursion, resulting in no recomputation of the function during recursive descent at previously computed points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xgrid</td><td>points between which to evaluate definite integrals. </td></tr>
    <tr><td class="paramname">partials</td><td>if non-NULL, a vector in which to receive the partial integrals. It will automatically be sized apprpropriately, if provided, to contain <em>n</em> - 1 elements where <em>n</em> is the length of <em>xgrid</em> </td></tr>
    <tr><td class="paramname">abs_tol</td><td>the absolute error bound for each segment </td></tr>
    <tr><td class="paramname">rel_tol</td><td>the fractional error bound for each segment. If the error is smaller than either the relative or absolute tolerance, the integration step is finished. </td></tr>
    <tr><td class="paramname">derivs</td><td>number of derivatives to trust, which sets the order of the integrator. The order is 3*<em>derivs</em> + 4. <em>derivs</em> can be 0, 1, or 2. </td></tr>
    <tr><td class="paramname">adapt</td><td>if true, use recursive adaptation, otherwise do simple evaluation on the grid provided with no error checking. </td></tr>
    <tr><td class="paramname">extrapolate</td><td>if true, use simple Richardson extrapolation on the final 2 steps to reduce the error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sum of partial integrals, which is the definite integral from the first value in <em>xgrid</em> to the last. </dd></dl>

</div>
</div>
<a class="anchor" id="a3f461317f09a62101e6114fd693fa20c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename float_type = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classc2__function.html">c2_function</a>&lt; float_type &gt;::preen_sampling_grid </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; float_type &gt; *&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>clean up endpoints on a grid of points </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">result</td><td>the sampling grid with excessively closely space endpoints removed. The grid is modified in place. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a25004cf23f56fafd0b64901354892f3c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename float_type = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classc2__function.html">c2_function</a>&lt; float_type &gt;::refine_sampling_grid </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; float_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>refinement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>refine a grid by splitting each interval into more intervals </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">grid</td><td>the grid to refine in place </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">refinement</td><td>the number of new steps for each old step </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af003b3e29357ccf65b7eba38be877b8c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename float_type = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classc2__function.html">c2_function</a>&lt; float_type &gt;::release_ownership_for_return </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"><a class="el" href="classc2__exception.html">c2_exception</a></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>decrement our reference count. Do not destroy at zero. </p>
<dl class="section return"><dt>Returns</dt><dd>final owner count, to check whether object should disappear. </dd></dl>

</div>
</div>
<a class="anchor" id="a23828c75121b442899ab7a80cf5abbb0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename float_type = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classc2__function.html">c2_function</a>&lt; float_type &gt;::set_sampling_grid </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; float_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>grid</em></td><td>)</td>
          <td></td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"><a class="el" href="classc2__exception.html">c2_exception</a></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>establish a grid of 'interesting' points on the function. </p>
<p>The sampling grid describes a reasonable initial set of points to look at the function. this should generally be set at a scale which is quite coarse, and sufficient for initializing adaptive integration or possibly root bracketing. For sampling a function to build a new interpolating function, one may want to refine this for accuracy. However, interpolating_functions themselves return their original X grid by default, so refining the grid in this case might be a bad idea. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>a vector of abscissas. The contents is copied into an internal vector, so the <em>grid</em> can be discarded after passingin. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adcf8bcc841ca3a1155ae115178ea88af"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename float_type = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classc2__function.html">c2_function</a>&lt;float_type&gt;&amp; <a class="el" href="classc2__function.html">c2_function</a>&lt; float_type &gt;::square_normalized_function </td>
          <td>(</td>
          <td class="paramtype">float_type&#160;</td>
          <td class="paramname"><em>amin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_type&#160;</td>
          <td class="paramname"><em>amax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_type&#160;</td>
          <td class="paramname"><em>norm</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"><a class="el" href="classc2__exception.html">c2_exception</a></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a new <a class="el" href="classc2__function.html" title="the parent class for all c2_functions.c2_functions know their value, first, and second derivative at ...">c2_function</a> from this one which is square-normalized on the interval </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">amin</td><td>lower bound of the domain for integration </td></tr>
    <tr><td class="paramname">amax</td><td>upper bound of the domain for integration </td></tr>
    <tr><td class="paramname">norm</td><td>the desired integral for the function over the region </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new <a class="el" href="classc2__function.html" title="the parent class for all c2_functions.c2_functions know their value, first, and second derivative at ...">c2_function</a> with the desired <em>norm</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="a9d8716e8abb9e02a188c243f825acf9b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename float_type = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classc2__function.html">c2_function</a>&lt;float_type&gt;&amp; <a class="el" href="classc2__function.html">c2_function</a>&lt; float_type &gt;::square_normalized_function </td>
          <td>(</td>
          <td class="paramtype">float_type&#160;</td>
          <td class="paramname"><em>amin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_type&#160;</td>
          <td class="paramname"><em>amax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classc2__function.html">c2_function</a>&lt; float_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_type&#160;</td>
          <td class="paramname"><em>norm</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"><a class="el" href="classc2__exception.html">c2_exception</a></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a new <a class="el" href="classc2__function.html" title="the parent class for all c2_functions.c2_functions know their value, first, and second derivative at ...">c2_function</a> from this one which is square-normalized with the provided <em>weight</em> on the interval </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">amin</td><td>lower bound of the domain for integration </td></tr>
    <tr><td class="paramname">amax</td><td>upper bound of the domain for integration </td></tr>
    <tr><td class="paramname">weight</td><td>a <a class="el" href="classc2__function.html" title="the parent class for all c2_functions.c2_functions know their value, first, and second derivative at ...">c2_function</a> providing the weight </td></tr>
    <tr><td class="paramname">norm</td><td>the desired integral for the function over the region </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new <a class="el" href="classc2__function.html" title="the parent class for all c2_functions.c2_functions know their value, first, and second derivative at ...">c2_function</a> with the desired <em>norm</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="a44e0201159111350be7f746fc9026f67"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename float_type = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual float_type <a class="el" href="classc2__function.html">c2_function</a>&lt; float_type &gt;::value_with_derivatives </td>
          <td>(</td>
          <td class="paramtype">float_type&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_type *&#160;</td>
          <td class="paramname"><em>yprime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_type *&#160;</td>
          <td class="paramname"><em>yprime2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"><a class="el" href="classc2__exception.html">c2_exception</a></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the value and derivatives. </p>
<p>There is required checking for null pointers on the derivatives, and most implementations should operate faster if derivatives are not needed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>the point at which to evaluate the function </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">yprime</td><td>the first derivative (if pointer is non-null) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">yprime2</td><td>the second derivative (if pointer is non-null) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the function </dd></dl>

<p>Implemented in <a class="el" href="classc2__piecewise__function__p.html#a24dda73e84778fa9eb2160195403c45f">c2_piecewise_function_p&lt; float_type &gt;</a>, <a class="el" href="classc2__connector__function__p.html#a0c748860e1ef547a0cce583c01abe175">c2_connector_function_p&lt; float_type &gt;</a>, <a class="el" href="classc2__inverse__function__p.html#a907dbfc4a1ea0530ae76a1ae8704f8ce">c2_inverse_function_p&lt; float_type &gt;</a>, <a class="el" href="classc2__power__law__p.html#a21f0088450f7b7110a001f4960e95fa1">c2_power_law_p&lt; float_type &gt;</a>, <a class="el" href="classc2__quadratic__p.html#ade79e98941853a179b2be14b6cc6daa3">c2_quadratic_p&lt; float_type &gt;</a>, <a class="el" href="classc2__linear__p.html#a1d6ce127c8e991c4293f530f341ce617">c2_linear_p&lt; float_type &gt;</a>, <a class="el" href="classc2__linear__p.html#a1d6ce127c8e991c4293f530f341ce617">c2_linear_p&lt; G4double &gt;</a>, <a class="el" href="classc2__identity__p.html#a69a30999382af761b9360179dbedbc88">c2_identity_p&lt; float_type &gt;</a>, <a class="el" href="classc2__recip__p.html#a0f05f680a8074a14c6d2ed5f5e1ebeca">c2_recip_p&lt; float_type &gt;</a>, <a class="el" href="classc2__sqrt__p.html#aef50454e3f093a7e956c3a994b46ce9d">c2_sqrt_p&lt; float_type &gt;</a>, <a class="el" href="classc2__exp__p.html#a1c5cb28b65356b2f2290ae11d651f93e">c2_exp_p&lt; float_type &gt;</a>, <a class="el" href="classc2__log__p.html#acd98067684930659e4a47390385e56b3">c2_log_p&lt; float_type &gt;</a>, <a class="el" href="classc2__tan__p.html#ac1e6ff8fd74a4d33ce189297fd16bbee">c2_tan_p&lt; float_type &gt;</a>, <a class="el" href="classc2__cos__p.html#ae4e275f2739d33bfbf1f2efc741535d5">c2_cos_p&lt; float_type &gt;</a>, <a class="el" href="classc2__sin__p.html#a9710a5d48360f4c6e1568f1ad849dd7b">c2_sin_p&lt; float_type &gt;</a>, <a class="el" href="classinterpolating__function__p.html#a321e6a9a8e598ebb0ae77ce265742ed7">interpolating_function_p&lt; float_type &gt;</a>, <a class="el" href="classc2__constant__p.html#a75ec878f6eb48c5ea0187197c645dd66">c2_constant_p&lt; float_type &gt;</a>, <a class="el" href="classc2__cached__function__p.html#a09f22efcdcf81c1a7b353d10e29b193c">c2_cached_function_p&lt; float_type &gt;</a>, <a class="el" href="classc2__scaled__function__p.html#a29f90a45574f413a18349e220287fb5d">c2_scaled_function_p&lt; float_type &gt;</a>, <a class="el" href="classc2__binary__function.html#a7ab60d022222ce65e99f8708bf2aae0d">c2_binary_function&lt; float_type &gt;</a>, <a class="el" href="classc2__plugin__function__p.html#a7a5f8926ecec5b73f32ad5f90cefe80e">c2_plugin_function_p&lt; float_type &gt;</a>, <a class="el" href="classc2__plugin__function__p.html#a7a5f8926ecec5b73f32ad5f90cefe80e">c2_plugin_function_p&lt; G4double &gt;</a>, and <a class="el" href="classc2__classic__function__p.html#abf7fc11b0396fc249eb3300ed39b3cc3">c2_classic_function_p&lt; float_type &gt;</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="c2__function_8hh_source.html">c2_function.hh</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jul 24 2017 14:08:55 for G4EMMA Header Files by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
